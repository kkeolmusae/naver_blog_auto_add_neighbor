# Generated by Selenium IDE
import time
import json
import pyperclip
import random
import traceback

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.keys import Keys

from utils import keyboard_control


with open("../login_info.json", "r") as json_file:
    st_python = json.load(json_file)


NAVER_ID = st_python.get("naver_id")
NAVER_PWD = st_python.get("naver_pwd")
buddy_add_comment = "안녕하세요. 공감글 타고 들어와 서이추 드립니다. 자주 소통하는 이웃이 되었으면 좋겠어요. 그럼 오늘도 행복한 하루 보내세요~"

def random_sleep_time():
    time.sleep(random.uniform(0.5, 1))
    

class NaverBlogAutoAddBuddy():
    def setup_method(self):
        self.driver = webdriver.Chrome()
        self.vars = {}
        self.wait_page_time = 10
    
    def teardown_method(self):
        self.driver.quit()
    
    def wait_next_window(self):
        print("start wait")
        WebDriverWait(self.driver, self.wait_page_time).until(EC.presence_of_element_located((By.CSS_SELECTOR, ".link_slogan")))
        print("start done")
        
    def wait_page_by_xpath(self, xpath: str):
        return WebDriverWait(self.driver, self.wait_page_time).until(EC.presence_of_element_located((By.XPATH, xpath)))
        
    def get_blog_post_list(self, next_page = False):
        print("start_blog_post_list")
        
        if next_page:
            self.wait_page_by_xpath("//a[contains(@class, 'button_next')]").click()
        else:
            self.driver.find_element(By.LINK_TEXT, "주제별 보기").click()
        random_sleep_time()
        
        black_list = ["강제추행", "구매대행", "음주뺑소니", "이슬아", "태도의", "1시간에", "스피치", "마그리트"]
        blog_len = len(self.driver.find_elements(By.CSS_SELECTOR, ".desc_inner"))
        for blog_i in range(blog_len):
            try:
                blog_list = self.driver.find_elements(By.CSS_SELECTOR, ".desc_inner")
                blog = blog_list[blog_i]
                
                
                blog_titles = self.driver.find_elements(By.XPATH, "//strong[contains(@class, 'title_post')]")
                remove_other_info_blog_titles = blog_titles[9:]
                blog_title = remove_other_info_blog_titles[blog_i].text
                if_black_list = False
                for black in black_list:
                    if black in blog_title:
                        if_black_list = True
                if if_black_list:
                    continue
                
                
                print(blog)
                blog.click()
                print(f"start blog ||| {blog_title}")
                random_sleep_time()
                
                tabs = self.driver.window_handles
                tag_id_blog_post = tabs[-1]
                self.driver.switch_to.window(tag_id_blog_post)
                
                # 블로그 내 frame이 있어 frame 속으로 접근
                self.driver.switch_to.frame("mainFrame") 
                
                # 공감글 접근, 이것도 frame로 되어있어서 frame를 찾아야됨.
                empathy_a_herf = self.wait_page_by_xpath("//a[contains(@id, 'Sympathy')]")
                empathy_a_herf.click()
                random_sleep_time()
                empathy_iframe = self.wait_page_by_xpath("//iframe[contains(@id, 'sympathyFrm')]")
                empathy_iframe_id = empathy_iframe.get_attribute("id")
                self.driver.switch_to.frame(empathy_iframe_id)
                    
                
                # 공감한 이웃 모두 받아오기
                buddy_list = self.driver.find_elements(By.XPATH, "//a[contains(@class, 'btn_buddy')]")
                
                
                for buddy_i in range(len(buddy_list)):
                    # 두번재 서이추 할 때 frame 이 벗어나
                    # frame 맞추기 추가
                    if buddy_i >= 1:
                        self.driver.switch_to.frame("mainFrame")
                        empathy_iframe = self.wait_page_by_xpath("//iframe[contains(@id, 'sympathyFrm')]")
                        empathy_iframe_id = empathy_iframe.get_attribute("id")
                        self.driver.switch_to.frame(empathy_iframe_id)
                    buddy = self.driver.find_elements(By.XPATH, "//div[contains(@class, 'wrap_bloger')]")[buddy_i]
                    buddy_add_buddy_buttom = buddy.find_elements(By.XPATH, "//a[contains(@class, 'btn_buddy')]")[buddy_i]
                    user_name = buddy.find_elements(By.XPATH, "//span[contains(@class, 'ell2')]/a")[buddy_i].text
                    
                    # + 이웃 추가 버튼이 있는 경우에만 클릭
                    if "이웃추가" in buddy_add_buddy_buttom.get_attribute("text"):
                        buddy_add_buddy_buttom.click()
                        random_sleep_time()
                        tag_id_add_buddy = self.driver.window_handles[-1]
                        self.driver.switch_to.window(tag_id_add_buddy)
                        
                        # 서이추 버튼 disable
                        each_buddy_add_button = self.wait_page_by_xpath("//input[contains(@id, 'each_buddy_add')]")
                        if each_buddy_add_button.get_attribute("disabled"):
                            self.driver.close()
                            
                        else:
                            self.wait_page_by_xpath("//label[contains(@for, 'each_buddy_add')]").click()
                            random_sleep_time()
                            next_button = self.wait_page_by_xpath("//a[contains(@class, '_buddyAddNext')]")
                            next_button.click()
                            random_sleep_time()
                            
                            
                            is_alert = False
                            # 서이추 버튼 클릭 후 알림창 대응
                            try:
                                alert_dialog = self.driver.switch_to.alert
                                alert_text = alert_dialog.text # TODO 서이추 그룹 추가여부 확인 필요
                                alert_dialog.accept()
                                is_alert = True
                                
                                # 1일 500명 모두 종료
                                if "더 이상 이웃을 추가할 수 없습니다" in alert_text:
                                    print("1일 500명 모두 완료!!")
                                    self.driver.quit()
                                    exit()
                            except:
                                pass


                            if not is_alert:
                                # 서로이웃 신청 메시지 쓰는 칸 입장
                                textarea = self.wait_page_by_xpath("//textarea[contains(@id, 'message')]")
                                textarea.click()
                                random_sleep_time()
                                textarea.send_keys(buddy_add_comment)
                                
                                # 다음 
                                textarea_popup_next_button = self.wait_page_by_xpath("//a[contains(@class, '_addBothBuddy')]")
                                textarea_popup_next_button.click()
                                random_sleep_time()
                                
                                # 최종 닫기 버튼 클릭
                                finsh_close_button = self.wait_page_by_xpath("//a[contains(@class, 'button_close')]")
                                finsh_close_button.click()
                                random_sleep_time()
                            
                    self.driver.switch_to.window(tag_id_blog_post)
                    random_sleep_time()

                
                # 1개의 블로그 모두 끝
                # 현재 블로그 닫기
                print(f"end blog ||| {blog_title}")
                self.driver.switch_to.window(tag_id_blog_post)
                self.driver.close()
                
                # 블로그 목록 가기
                self.driver.switch_to.window(self.driver.window_handles[0])
            except :
                print("===========================================")
                traceback.format_exc()
                print(f"ERROR {blog_title} {user_name}")
                print("===========================================")
                
            
        print(1)
        
        self.get_blog_post_list(next_page = True)


    def login_naver(self):
        self.driver.get("https://section.blog.naver.com/BlogHome.naver?directoryNo=0&currentPage=1&groupId=0")
        self.driver.set_window_size(1920, 1080)
        self.driver.find_element(By.CSS_SELECTOR, ".login_button").click()
        random_sleep_time()
        
        
        # 3. id 복사 붙여넣기
        elem_id = self.wait_page_by_xpath("//input[contains(@id, 'id') and contains(@placeholder, '아이디')]")
        random_sleep_time()
        elem_id.click()
        pyperclip.copy(NAVER_ID)
        random_sleep_time()
        elem_id.send_keys(keyboard_control(), 'v')
        
        # 4. pw 복사 붙여넣기
        elem_pw = self.wait_page_by_xpath("//input[contains(@id, 'pw') and contains(@placeholder, '비밀번호')]")
        random_sleep_time()
        elem_pw.click()
        random_sleep_time()
        pyperclip.copy(NAVER_PWD)
        random_sleep_time()
        elem_pw.send_keys(keyboard_control(), 'v')
        random_sleep_time()
        
        # 8 | click | id=log.login | 
        self.driver.find_element(By.ID, "log.login").click()
        

if __name__ == "__main__":
    t = NaverBlogAutoAddBuddy()
    t.setup_method()
    t.login_naver()
    t.wait_next_window()
    t.get_blog_post_list()